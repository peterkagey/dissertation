\begin{verbatim}
  import Helpers.Factorials (factorial)
  import Data.List (sort, nub)

  type Prefix = [Int]
  type PolynomialCoeffs = [Integer]
  type PrefixCount = Prefix -> Integer

  rookCount :: Int -> Integer -> Prefix
  rookCount n = unrank n n (rookPrefixCount n)

  -- unrank from alphabet of size n with k letters
  -- and a way of counting the number of words with a given prefix
  unrank :: Int ->                 -- Alphabet of n letters
            Int ->                 -- Words of length k
            (Prefix -> Integer) -> -- #prefix function
            Integer ->             -- Unrank at i
            Prefix                 -- Word at rank i
  unrank n k prefixCounter i = recurse (0, 0) 1 [] where
    recurse :: (Integer, Integer) -> -- index range for prefix (a, b]
               Int ->                -- candidate for current letter
               Prefix ->             -- established prefix
               Prefix                -- word at index
    recurse (a, b) c prefix
      | c > n              = error "Out of range!"
      | length prefix == k = prefix
      | a < i && i <= b    = recurse (a, b') 1 (prefix  ++ [c])
      | otherwise          = recurse (b, b'') (c + 1) prefix where
      b'      = a + prefixCounter (prefix ++ [c, 1])
      b''     = b + prefixCounter (prefix  ++ [c + 1])

  -- Assumes prefix is valid; no duplicate values or illegal positions.
  -- If n = 9 and the prefix is [3, 8, 7]
  -- This should return [[1,2],[4,5,6],[9]]
  getColGroups :: Int -> Prefix -> [[Int]]
  getColGroups n prefix = filter (not . null) $ colGroups where
    cols = 0 : (sort prefix) ++ [n+1]
    colGroups = zipWith (\a b ->  [a+1..b-1]) cols (tail cols)

  blockSizesFromPrefix :: Int -> Prefix -> [Int]
  blockSizesFromPrefix n prefix = map (sum . map colCells) colGroups where
    colGroups = getColGroups n prefix
    k = length prefix
    colCells c
      | c < k      = 0
      | c == k     = 1
      | c == n     = 1
      | otherwise  = 2

  fibonacciPoly :: Int -> PolynomialCoeffs
  fibonacciPoly = (!!) fibonacciPolynomials where
    fibonacciPolynomials = [1] : [1] : recurse [1] [1] where
      recurse f g = h : recurse g h where
        h = ([0,1] .*. f) .+. g

  complementaryRookPolynomial :: Int -> Prefix -> PolynomialCoeffs
  complementaryRookPolynomial n prefix = foldr (.*.) [1] blockPolys where
    blockPolys = map (\i -> fibonacciPoly (i + 1)) blockSizes where
      blockSizes = blockSizesFromPrefix n prefix

  invalidPrefix :: Int -> Prefix -> Bool
  invalidPrefix n prefix = containsDuplicates || invalidPosition where
    containsDuplicates = prefix /= (nub prefix)
    invalidPosition = any inRestrictedPosition $ zip [0..] prefix where
      inRestrictedPosition (i, x) = (x `mod` n == i) || (x == i + 1)

  rookPrefixCount :: Int -> Prefix -> Integer
  rookPrefixCount n prefix
    | invalidPrefix n prefix = 0
    | otherwise      = recurse 0 crp where
    n' = fromIntegral (n - length prefix)
    crp = complementaryRookPolynomial n prefix
    recurse k (c:cs) = (-1)^k * c * factorial (n'-k) + recurse (k+1) cs
    recurse _ [] = 0

  -- The polynomial a + bx + cx^2 ... is represented as
  -- [a, b, c, ...]
  -- These are helper functions for adding and multiplying polynomials
  (.+.) :: PolynomialCoeffs -> PolynomialCoeffs -> PolynomialCoeffs
  (.+.) p1 [] = p1
  (.+.) [] p2 = p2
  (.+.) (a:p1) (b:p2) = (a + b) : (p1 .+. p2)

  (.*.) :: PolynomialCoeffs -> PolynomialCoeffs -> PolynomialCoeffs
  (.*.) p1 [] = []
  (.*.) [] p2 = []
  (.*.) p1 p2 = foldr1 (.+.) termwiseProduct where
    termwiseProduct = map f $ zip [0..] p1 where
      f (i, x) = replicate i 0 ++ map (*x) p2
\end{verbatim}
