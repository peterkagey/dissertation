\begin{lstlisting}
  import Helpers.Factorials (factorial)
  import Data.List (sort, nub)

  type Prefix = [Int]
  type PolynomialCoefficients = [Integer]
  type PrefixCount = Prefix -> Integer

  rookCount :: Int -> Integer -> Prefix
  rookCount n = unrank n n (rookPrefixCount n)

  -- unrank from alphabet of size n with k letters
  -- and a way of counting the number of words with a given prefix
  unrank :: Int ->                 -- Alphabet of n letters
            Int ->                 -- Words of length k
            (Prefix -> Integer) -> -- #prefix function
            Integer ->             -- Unrank at targetIndex
            Prefix                 -- Word at rank targetIndex
  unrank n k prefixCounter targetIndex = recurse (0, 0) 1 [] where
    recurse :: (Integer, Integer) -> -- index range with given prefix (a, b]
               Int ->                -- candidate for current letter
               Prefix ->             -- established prefix
               Prefix                -- word at index
    recurse (a, b) c prefix
      | c > n                               = error "Out of range!"
      | length prefix == k                  = prefix
      | a < targetIndex && targetIndex <= b = recurse (a, b') 1 (prefix  ++ [c])
      | otherwise                           = recurse (b, b'') (c + 1) prefix where
      b'      = a + prefixCounter (prefix ++ [c, 1])
      b''     = b + prefixCounter (prefix  ++ [c + 1])

  -- Assumes prefix is valid; no duplicate values or illegal positions.
  -- If n = 9 and the prefix is [3, 8, 7]
  -- This should return [[1,2],[4,5,6],[9]]
  getColumnGroups :: Int -> Prefix -> [[Int]]
  getColumnGroups n prefix = filter (not . null) $ columnGroups where
    cols = 0 : (sort prefix) ++ [n+1]
    columnGroups = zipWith (\a b ->  [a+1..b-1]) cols (tail cols)

  getComposition :: Int -> Prefix -> [Int]
  getComposition n prefix = map (sum . map cellsInColumn) columnGroups where
    columnGroups = getColumnGroups n prefix
    k = length prefix
    cellsInColumn c
      | c < k      = 0
      | c == k     = 1
      | c == n     = 1
      | otherwise  = 2

  fibonacciPolynomial :: Int -> PolynomialCoefficients
  fibonacciPolynomial = (!!) fibonacciPolynomials where
    fibonacciPolynomials = [1] : [1] : recurse [1] [1] where
      recurse f g = h : recurse g h where
        h = ([0,1] .*. f) .+. g

  complementaryRookPolynomial :: Int -> Prefix -> PolynomialCoefficients
  complementaryRookPolynomial n prefix = foldr (.*.) [1] blockPolynomials where
    blockPolynomials = map (\i -> fibonacciPolynomial (i + 1)) $ getComposition n prefix

  invalidPrefix :: Int -> Prefix -> Bool
  invalidPrefix n prefix = containsDuplicates || invalidPosition where
    containsDuplicates = prefix /= (nub prefix)
    invalidPosition = any inRestrictedPosition $ zip [0..] prefix where
      inRestrictedPosition (i, x) = (x `mod` n == i) || (x == i + 1)

  rookPrefixCount :: Int -> Prefix -> Integer
  rookPrefixCount n prefix
    | invalidPrefix n prefix = 0
    | otherwise      = recurse 0 crp where
    n' = fromIntegral (n - length prefix)
    crp = complementaryRookPolynomial n prefix
    recurse k (c:cs) = (-1)^k * c * factorial (n'-k) + recurse (k+1) cs
    recurse _ [] = 0

  -- The polynomial a + bx + cx^2 ... is represented as
  -- [a, b, c, ...]
  -- These are helper functions for adding and multiplying polynomials
  (.+.) :: PolynomialCoefficients -> PolynomialCoefficients -> PolynomialCoefficients
  (.+.) p1 [] = p1
  (.+.) [] p2 = p2
  (.+.) (a:p1) (b:p2) = (a + b) : (p1 .+. p2)

  (.*.) :: PolynomialCoefficients -> PolynomialCoefficients -> PolynomialCoefficients
  (.*.) p1 [] = []
  (.*.) [] p2 = []
  (.*.) p1 p2 = foldr1 (.+.) termwiseProduct where
    termwiseProduct = map (\(i,x) -> replicate i 0 ++ map (*x) p2) $ zip [0..] p1
\end{lstlisting}
